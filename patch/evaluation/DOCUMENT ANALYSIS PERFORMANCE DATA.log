retrofit-master:{No Variable In Annotation=0, false=0, true=0, No Throw Annotation=150}
True :
False :





joda-time-master:{No Variable In Annotation=83, false=33, true=101, No Throw Annotation=1255}
True :
if the field is null or unsupported / field.isSupported() == false / [type, this, type == null]
if the field is null or unsupported / field.isSupported() == false / [field, type, this, field.isSupported() == false]
if the date is invalid for the ISO chronology / date == null / [date, iLocalMillis, iChronology, this, date == null]
if the date is invalid for the ISO chronology / date == null / [date, iLocalMillis, iChronology, this, date.getTime() < 0, date.getTime()]
if the field type is null / type == null / [type, iLocalMillis, iChronology, this, type == null]
if the field type is null or unsupported / field == null / [field, value, this, field == null]
if the field type is null or unsupported / field == null / [field, value, this, field == null]
if the field type is null or unsupported / field == null / [field, value, this, value == 0]
if the partial is null / partial == null / [partial, cMillisProvider, cZoneNames, this, partial == null]
if the date is invalid for the ISO chronology / date == null / [date, this, date == null]
if the date is invalid for the ISO chronology / date == null / [date, iLocalMillis, iChronology, this, date == null]
if the field type is null / fieldType == null / [fieldType, iLocalMillis, iChronology, this, fieldType == null]
if the field type is null / fieldType == null / [fieldType, iLocalMillis, iChronology, this, isSupported(fieldType) == false]
if the zone is null / zone == null / [sm, zone, cProvider, cNameProvider, cDefault, iID, iID, this, sm == null]
if the zone is null / zone == null / [sm, zone, cProvider, cNameProvider, cDefault, iID, iID, this, zone == null]
if the id is null / id == null / [id, this, id == null]
if the interval is null / interval == null / [interval, this, interval == null]
if the field is null or unsupported / field.isSupported() == false / [type, this, type == null]
if the field is null or unsupported / field.isSupported() == false / [field, type, this, field.isSupported() == false]
if the date is invalid for the ISO chronology / date == null / [date, this, date == null]
if the type or value is invalid / type == null / [type, value, chronology, this, type == null]
if the types or values are invalid / types == null / [types, values, chronology, this, types == null]
if the types or values are invalid / values == null / [types, values, chronology, this, types == null]
if the types or values are invalid / types == null / [types, values, chronology, this, values == null]
if the types or values are invalid / values == null / [types, values, chronology, this, values == null]
if the types or values are invalid / types == null / [types, values, chronology, this, values.length == types.length]
if the types or values are invalid / values == null / [types, values, chronology, this, values.length == types.length]
if the types or values are invalid / types == null / [types, values, chronology, this, types.length == 0]
if the types or values are invalid / values == null / [types, values, chronology, this, types.length == 0]
if the specified partial is null / partial == null / [partial, this, partial == null]
if the specified partial is null / partial == null / [partial, this, partial == null]
if the specified partial is null / partial == null / [partial, this, partial == null]
if the field type is null / type == null / [type, this, type == null]
if the field type is null / type == null / [type, this, type == null]
if the field is null / field == null / [field, this, field == null]
if the index is invalid / index != 0 / [index, iPeriod, this, index == 0]
if the index is invalid / index != 0 / [index, iPeriod, this, index == 0]
if the other period is of a different type / other.getClass() != getClass() / [other, iPeriod, this, other.getClass() == getClass()]
if the other period is of a different type / other.getClass() != getClass() / [otherValue, thisValue, other, iPeriod, this, thisValue > otherValue]
if the other period is of a different type / other.getClass() != getClass() / [otherValue, thisValue, other, iPeriod, this, thisValue < otherValue]
if the field is null or unsupported / field.isSupported() == false / [type, iRoundingField, iRoundingMode, this, type == null]
if the field is null or unsupported / field.isSupported() == false / [field, type, iRoundingField, iRoundingMode, this, field.isSupported() == false]
if the date is invalid for the ISO chronology / date == null / [date, iLocalMillis, iChronology, iHash, this, date == null]
if the date is invalid for the ISO chronology / date == null / [date, iLocalMillis, iChronology, iHash, this, date.getTime() < 0, date.getTime()]
if the field type is null or unsupported / fieldType == null / [fieldType, iLocalMillis, iChronology, iHash, this, fieldType == null]
if the field type is null or unsupported / fieldType == null / [fieldType, iLocalMillis, iChronology, iHash, this, isSupported(fieldType) == false]
if the chronology of the time does not match / time == null / [time, iLocalMillis, iChronology, iHash, this, time == null]
if the chronology of the time does not match / getChronology() != time.getChronology() / [time, iLocalMillis, iChronology, iHash, this, time == null]
if the chronology of the time does not match / time == null / [time, iLocalMillis, iChronology, iHash, this, getChronology() == time.getChronology()]
if the chronology of the time does not match / getChronology() != time.getChronology() / [time, iLocalMillis, iChronology, iHash, this, getChronology() == time.getChronology()]
if the chronology of the time does not match / getChronology() != time.getChronology() / [time, zone, iLocalMillis, iChronology, iHash, this, time == null]
if the chronology of the time does not match / getChronology() != time.getChronology() / [time, zone, iLocalMillis, iChronology, iHash, this, getChronology() == time.getChronology()]
if the period is null / period == null / [period, iPrinter, iParser, iLocale, iParseType, this, period == null]
if formatter is null or of an invalid type / formatter == null / [formatter, iElementPairs, iFormatter, this, formatter == null]
if text is null / text == null / [text, iElementPairs, iFormatter, this, text == null]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this, fieldType == null]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this, maxDigits < minDigits]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this, minDigits <= 1]
if field type is null or if <code>numDigits <= 0</code> / fieldType == null / [fieldType, numDigits, iElementPairs, iFormatter, this, fieldType == null]
if field type is null or if <code>numDigits <= 0</code> / numDigits <= 0 / [fieldType, numDigits, iElementPairs, iFormatter, this, fieldType == null]
if field type is null or if <code>numDigits <= 0</code> / fieldType == null / [fieldType, numDigits, iElementPairs, iFormatter, this, numDigits <= 0]
if field type is null or if <code>numDigits <= 0</code> / numDigits <= 0 / [fieldType, numDigits, iElementPairs, iFormatter, this, numDigits <= 0]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this, fieldType == null]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this, maxDigits < minDigits]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this, minDigits <= 1]
if field type is null or if <code>numDigits <= 0</code> / fieldType == null / [fieldType, numDigits, iElementPairs, iFormatter, this, fieldType == null]
if field type is null or if <code>numDigits <= 0</code> / numDigits <= 0 / [fieldType, numDigits, iElementPairs, iFormatter, this, fieldType == null]
if field type is null or if <code>numDigits <= 0</code> / fieldType == null / [fieldType, numDigits, iElementPairs, iFormatter, this, numDigits <= 0]
if field type is null or if <code>numDigits <= 0</code> / numDigits <= 0 / [fieldType, numDigits, iElementPairs, iFormatter, this, numDigits <= 0]
if field type is null / fieldType == null / [fieldType, iElementPairs, iFormatter, this, fieldType == null]
if field type is null / fieldType == null / [fieldType, iElementPairs, iFormatter, this, fieldType == null]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this, fieldType == null]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this, maxDigits < minDigits]
if field type is null / fieldType == null / [fieldType, minDigits, maxDigits, iElementPairs, iFormatter, this]
if text is null / text == null / [text, iMinPrintedDigits, iPrintZeroSetting, iMaxParsedDigits, iRejectSignedValues, iPrefix, iElementPairs, iNotPrinter, iNotParser, iFieldFormatters, iMinPrintedDigits, iPrintZeroSetting, iMaxParsedDigits, iRejectSignedValues, iFieldFormatters, iPrefix, this, text == null]
if chronology or time zone is null / zone == null / [base, zone, this, base == null]
if chronology or time zone is null / zone == null / [base, zone, this, base == null]
if chronology or time zone is null / zone == null / [base, zone, this, zone == null]
if divisor is less than two / divisor < 2 / [field, type, divisor, this, divisor < 2]
if divisor is less than two / divisor < 2 / [rangeField, field, type, divisor, this, rangeField == null]
if divisor is less than two / divisor < 2 / [field, rangeField, type, divisor, this, divisor < 2]
if unit milliseconds is less than one / unit.isPrecise() / [type, unit, this, !unit.isPrecise()]
if unit milliseconds is less than one / unit.isPrecise() / [type, unit, this, iUnitMillis < 1, iUnitMillis]
if the instant is null or the instant doesn't support the field of this property / instant == null / [instant, this, instant == null]
if the instant is null or the instant doesn't support the field of this property / instant == null / [thisValue, otherValue, instant, this, thisValue < otherValue]
if the instant is null or the instant doesn't support the field of this property / instant == null / [thisValue, otherValue, instant, this, thisValue > otherValue]
if the value is Integer.MIN_VALUE / value == Integer.MIN_VALUE / [value, this, value == Integer.MIN_VALUE]
if the instant is null / instant == null / [instant, this, instant == null]
if the instant is null / instant == null / [thisValue, otherValue, instant, this, thisValue < otherValue]
if the instant is null / instant == null / [thisValue, otherValue, instant, this, thisValue > otherValue]
if the partial doesn't support this field / partial == null / [partial, this, partial == null]
if the partial doesn't support this field / partial == null / [thisValue, otherValue, partial, this, thisValue < otherValue]
if the partial doesn't support this field / partial == null / [thisValue, otherValue, partial, this, thisValue > otherValue]
if divisor is less than two / divisor < 2 / [field, rangeField, type, divisor, this, divisor < 2]
if divisor is less than two / divisor < 2 / [unitField, field, rangeField, type, divisor, this, unitField == null]
if unit milliseconds is less than one or effective value range is less than two. / range.isPrecise() / [type, unit, range, this, !range.isPrecise()]
if unit milliseconds is less than one or effective value range is less than two. / iRange < 2 / [type, unit, range, this, !range.isPrecise()]
if unit milliseconds is less than one or effective value range is less than two. / range.isPrecise() / [rangeMillis, type, unit, range, this, iRange < 2, iRange]
if unit milliseconds is less than one or effective value range is less than two. / iRange < 2 / [rangeMillis, type, unit, range, this, iRange < 2, iRange]
False :


if the value is null or invalid / fieldType == null / [fieldType, value, this, fieldType == null]
if the field is null or unsupported / type == null / [field, type, this, field.isSupported() == false]
if the value is null or invalid / fieldType == null / [fieldType, value, iLocalMillis, iChronology, this, fieldType == null]
if the value is null or invalid / fieldType == null / [fieldType, value, iLocalMillis, iChronology, this, fieldType == null]
if the value is null or invalid / fieldType == null / [fieldType, value, iLocalMillis, iChronology, this, isSupported(fieldType) == false]
if the zone is not recognised / id == null / [zone, cProvider, cNameProvider, cDefault, iID, iID, this, zone == null]
if the zone is not recognised / id == null / [id, zone, cProvider, cNameProvider, cDefault, iID, iID, this, id == null]
if the zone is not recognised / id == null / [id, zone, cProvider, cNameProvider, cDefault, iID, iID, this, id.equals("UTC")]
if the zone is not recognised / id == null / [id, dtz, convId, provider, zone, cProvider, cNameProvider, cDefault, iID, iID, this, convId == null]
if the zone is not recognised / id == null / [id, dtz, convId, provider, zone, cProvider, cNameProvider, cDefault, iID, iID, this, dtz == null]
if the zone is not recognised / id == null / [id, dtz, convId, provider, zone, cProvider, cNameProvider, cDefault, iID, iID, this, dtz == null]
if the zone is not recognised / id == null / [id, dtz, convId, provider, zone, cProvider, cNameProvider, cDefault, iID, iID, this, convId == null]
if the provider is invalid / ids.contains("UTC") / [ids, provider, cProvider, cNameProvider, cDefault, iID, iID, this]
if the provider is invalid / UTC.equals(provider.getZone("UTC")) / [ids, provider, cProvider, cNameProvider, cDefault, iID, iID, this]
if the provider is invalid / ids.contains("UTC") / [ids, provider, cProvider, cNameProvider, cDefault, iID, iID, this, !ids.contains("UTC")]
if the provider is invalid / UTC.equals(provider.getZone("UTC")) / [ids, provider, cProvider, cNameProvider, cDefault, iID, iID, this, !ids.contains("UTC")]
if the provider is invalid / ids.contains("UTC") / [ids, provider, cProvider, cNameProvider, cDefault, iID, iID, this, !UTC.equals(provider.getZone("UTC"))]
if the provider is invalid / UTC.equals(provider.getZone("UTC")) / [ids, provider, cProvider, cNameProvider, cDefault, iID, iID, this, !UTC.equals(provider.getZone("UTC"))]
if the value is null or invalid / fieldType == null / [fieldType, value, this, fieldType == null]
if the field is null or unsupported / type == null / [field, type, this, field.isSupported() == false]
if the value is null or invalid / fieldType == null / [fieldType, value, iChronology, iTypes, iValues, iFormatter, this, fieldType == null]
if the value is null or invalid / fieldType == null / [index, fieldType, value, iChronology, iTypes, iValues, iFormatter, this, index == -1]
if the value is null or invalid / fieldType == null / [index, fieldType, value, iChronology, iTypes, iValues, iFormatter, this, value == getValue(index)]
if the value is null or invalid / type == null / [type, value, iRoundingField, iRoundingMode, this, type == null]
if the field is null or unsupported / type == null / [field, type, iRoundingField, iRoundingMode, this, field.isSupported() == false]
if chronology or time zone is null / base == null / [base, zone, this, base == null]
if chronology or time zone is null / base == null / [base, zone, this, base == null]
if chronology or time zone is null / base == null / [base, zone, this, base == null]
if chronology or time zone is null / base == null / [base, zone, this, base == null]
if chronology or time zone is null / base == null / [base, zone, this, zone == null]
if chronology or time zone is null / base == null / [base, zone, this, zone == null]
if unit milliseconds is less than one / iUnitMillis < 1 / [type, unit, this, !unit.isPrecise()]
if unit milliseconds is less than one / iUnitMillis < 1 / [type, unit, this, iUnitMillis < 1, iUnitMillis]



commons-lang-master:{No Variable In Annotation=264, false=27, true=85, No Throw Annotation=3196}
True :
if the collection is empty / collection.isEmpty() / [collection, message, values, this, collection == null]
if the collection is empty / collection.isEmpty() / [collection, message, values, this, collection.isEmpty()]
if the map is empty / map.isEmpty() / [map, message, values, this, map == null]
if the map is empty / map.isEmpty() / [map, message, values, this, map.isEmpty()]
if type argument is not assignable to the specified superType / superType.isAssignableFrom(type) == false / [this, superType.isAssignableFrom(type) == false]
if the width is too small / maxWidth < 4 / [str, offset, maxWidth, this, str == null]
if the width is too small / maxWidth < 7 / [str, offset, maxWidth, this, str == null]
if the width is too small / maxWidth < 4 / [str, offset, maxWidth, this, maxWidth < 4]
if the width is too small / maxWidth < 7 / [str, offset, maxWidth, this, maxWidth < 4]
if the width is too small / maxWidth < 4 / [str, offset, maxWidth, this, str.length() <= maxWidth]
if the width is too small / maxWidth < 7 / [str, offset, maxWidth, this, str.length() <= maxWidth]
if the width is too small / maxWidth < 4 / [str, offset, maxWidth, this, offset > str.length()]
if the width is too small / maxWidth < 7 / [str, offset, maxWidth, this, offset > str.length()]
if the width is too small / maxWidth < 4 / [str, offset, maxWidth, this, str.length() - offset < maxWidth - 3]
if the width is too small / maxWidth < 7 / [str, offset, maxWidth, this, str.length() - offset < maxWidth - 3]
if the width is too small / maxWidth < 4 / [abrevMarker, str, offset, maxWidth, this, offset <= 4]
if the width is too small / maxWidth < 7 / [abrevMarker, str, offset, maxWidth, this, offset <= 4]
if the width is too small / maxWidth < 4 / [abrevMarker, str, offset, maxWidth, this, maxWidth < 7]
if the width is too small / maxWidth < 7 / [abrevMarker, str, offset, maxWidth, this, maxWidth < 7]
if the width is too small / maxWidth < 4 / [abrevMarker, str, offset, maxWidth, this, offset + maxWidth - 3 < str.length()]
if the width is too small / maxWidth < 7 / [abrevMarker, str, offset, maxWidth, this, offset + maxWidth - 3 < str.length()]
if the specified thread name or group name is null / threadName == null / [threadName, threadGroupName, this, threadName == null]
if the specified thread name or group name is null / threadGroupName == null / [threadName, threadGroupName, this, threadName == null]
if the specified thread name or group name is null / threadName == null / [threadName, threadGroupName, this, threadGroupName == null]
if the specified thread name or group name is null / threadGroupName == null / [threadName, threadGroupName, this, threadGroupName == null]
if the specified thread name or group name is null / threadName == null / [threadGroups, threadName, threadGroupName, this, threadGroups.isEmpty()]
if the specified thread name or group name is null / threadGroupName == null / [threadGroups, threadName, threadGroupName, this, threadGroups.isEmpty()]
if the given group or predicate is null / group == null / [group, recurse, predicate, this, group == null]
if the given group or predicate is null / predicate == null / [group, recurse, predicate, this, group == null]
if the given group or predicate is null / group == null / [group, recurse, predicate, this, predicate == null]
if the given group or predicate is null / predicate == null / [group, recurse, predicate, this, predicate == null]
if the given group or predicate is null / group == null / [group, recurse, predicate, this, group == null]
if the given group or predicate is null / predicate == null / [group, recurse, predicate, this, group == null]
if the given group or predicate is null / group == null / [group, recurse, predicate, this, predicate == null]
if the given group or predicate is null / predicate == null / [group, recurse, predicate, this, predicate == null]
if the type argument is null / type == null / [array, type, this, type == null]
if the type argument is null / type == null / [array, type, this, array == null]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / numerator < 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, denominator == 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / numerator < 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, denominator < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / numerator < 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, numerator < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / numerator < 0 / [numeratorValue, whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, whole < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / numerator < 0 / [numeratorValue, whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this]
if the denominator is <code>zero</code> / denominator == 0 / [numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, denominator == 0]
if the denominator is <code>zero</code> / denominator == 0 / [numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, numerator == 0]
if the denominator is <code>zero</code> / denominator == 0 / [numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this]
if the denominator is <code>zero</code> / denominator == 0 / [numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this]
if the fraction is <code>null</code> / fraction == null / [fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, fraction == null]
if the fraction is <code>null</code> / fraction == null / [fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, numerator == 0]
if the fraction is <code>null</code> / fraction == null / [fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, fraction.numerator == 0]
if the fraction is <code>null</code> / fraction == null / [d1, fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, d1 == 1]
if the fraction is <code>null</code> / fraction == null / [d1, uvp, upv, t, tmodd1, d2, w, fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, w.bitLength() > 31, w.bitLength()]
if the fraction is <code>null</code> / fraction == null / [fraction, numerator, denominator, hashCode, toString, toProperString, this, fraction == null]
if the fraction is <code>null</code> / fraction == null / [fraction, numerator, denominator, hashCode, toString, toProperString, this]
if the fraction is <code>null</code> / fraction == null / [fraction, numerator, denominator, hashCode, toString, toProperString, this, fraction == null]
if the fraction is <code>null</code> / fraction == null / [fraction, numerator, denominator, hashCode, toString, toProperString, this, fraction.numerator == 0]
if <code>array</code> is empty / array == null / [array, this, array == null]
if <code>array</code> is empty / array == null / [array, this, array == null]
if <code>array</code> is empty / array == null / [array, this, array== null]
if <code>array</code> is empty / array == null / [array, this, array == null]
if the style is <code>null</code> / style == null / [style, defaultStyle, buffer, object, style, this, style == null]
if the prefix matcher is null / prefixMatcher == null / [prefixMatcher, escapeChar, prefixMatcher, suffixMatcher, valueDelimiterMatcher, enableSubstitutionInVariables, preserveEscapes, this, prefixMatcher == null]
if the prefix is null / prefix == null / [prefix, escapeChar, prefixMatcher, suffixMatcher, valueDelimiterMatcher, enableSubstitutionInVariables, preserveEscapes, this, prefix == null]
if the suffix matcher is null / suffixMatcher == null / [suffixMatcher, escapeChar, prefixMatcher, suffixMatcher, valueDelimiterMatcher, enableSubstitutionInVariables, preserveEscapes, this, suffixMatcher == null]
if the suffix is null / suffix == null / [suffix, escapeChar, prefixMatcher, suffixMatcher, valueDelimiterMatcher, enableSubstitutionInVariables, preserveEscapes, this, suffix == null]
if the date is null / date == null / [date, calendarField, amount, fields, this, date == null]
if the date is null / date == null / [date, calendarField, amount, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date instanceof Date]
if the date is <code>null</code> / date == null / [date, field, fields, this, date instanceof Calendar]
if the date is <code>null</code> / date == null / [date, field, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date instanceof Date]
if the date is <code>null</code> / date == null / [date, field, fields, this, date instanceof Calendar]
if the date is <code>null</code> / date == null / [date, field, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date == null]
if the date is <code>null</code> / date == null / [date, field, fields, this, date instanceof Date]
if the date is <code>null</code> / date == null / [date, field, fields, this, date instanceof Calendar]
if the date is <code>null</code> or  fragment is not supported / date == null / [date, fragment, unit, fields, this, date == null]
if the stream is <code>null</code> / stream == null / [throwable, stream, this, throwable == null]
if the stream is <code>null</code> / stream == null / [throwable, stream, this, stream == null]
if the writer is <code>null</code> / writer == null / [throwable, writer, this, throwable == null]
if the writer is <code>null</code> / writer == null / [throwable, writer, this, writer == null]
False :


if the value is not a number / Double.isNaN(value) / [value, message, values, this, Double.isNaN(value)]
if the denominator is <code>zero</code> or the denominator is   and the numerator is / denominator == 0 / [numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, denominator == 0]
if the denominator is <code>zero</code> or the denominator is   and the numerator is / denominator == 0 / [numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator == 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, denominator == 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator < 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, denominator == 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator == 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, denominator < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator < 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, denominator < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator == 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, numerator < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator < 0 / [whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, numerator < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator == 0 / [numeratorValue, whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, whole < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator < 0 / [numeratorValue, whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this, whole < 0]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator == 0 / [numeratorValue, whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this]
if the resulting numerator exceeds  <code>Integer.MAX_VALUE</code> / denominator < 0 / [numeratorValue, whole, numerator, denominator, numerator, denominator, hashCode, toString, toProperString, this]
if the resulting numerator or denominator cannot be represented in an <code>int</code>. / w.bitLength() > 31 / [fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, fraction == null]
if the resulting numerator or denominator cannot be represented in an <code>int</code>. / w.bitLength() > 31 / [fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, numerator == 0]
if the resulting numerator or denominator cannot be represented in an <code>int</code>. / w.bitLength() > 31 / [fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, fraction.numerator == 0]
if the resulting numerator or denominator cannot be represented in an <code>int</code>. / w.bitLength() > 31 / [d1, fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, d1 == 1]
if the resulting numerator or denominator cannot be represented in an <code>int</code>. / w.bitLength() > 31 / [d1, uvp, upv, t, tmodd1, d2, w, fraction, isAdd, numerator, denominator, hashCode, toString, toProperString, this, w.bitLength() > 31, w.bitLength()]
if <code>rhs</code> is not assignment-compatible with <code>lhs</code> / lhsClazz.isInstance(rhs) / [lhs, rhs, compareTransients, excludeFields, comparison, this, lhs == rhs]
if <code>rhs</code> is not assignment-compatible with <code>lhs</code> / lhsClazz.isInstance(rhs) / [lhs, rhs, compareTransients, excludeFields, comparison, this]
if <code>rhs</code> is not assignment-compatible with <code>lhs</code> / lhsClazz.isInstance(rhs) / [lhs, rhs, compareTransients, excludeFields, comparison, this, !lhsClazz.isInstance(rhs)]
if the rangeStyle is invalid / focus == null / [focus, rangeStyle, fields, this, focus == null]
if the rangeStyle is invalid / focus == null / [focus, rangeStyle, fields, this, focus == null]
if the rangeStyle is invalid / focus == null / [start, end, startCutoff, endCutoff, focus, rangeStyle, fields, this, startCutoff < Calendar.SUNDAY]
if the rangeStyle is invalid / focus == null / [start, end, startCutoff, endCutoff, focus, rangeStyle, fields, this, startCutoff > Calendar.SATURDAY]
if the rangeStyle is invalid / focus == null / [start, end, startCutoff, endCutoff, focus, rangeStyle, fields, this, endCutoff < Calendar.SUNDAY]
if the rangeStyle is invalid / focus == null / [start, end, startCutoff, endCutoff, focus, rangeStyle, fields, this, endCutoff > Calendar.SATURDAY]



elasticsearch-master:{No Variable In Annotation=31, false=11, true=8, No Throw Annotation=10880}
True :
if initialSize is negative / initialSize < 0 / [initialSize, this, initialSize < 0]
If readAheadLimit is &lt; 0 / readAheadLimit < 0 / [readAheadLimit, str, length, next, mark, this, readAheadLimit < 0]
if provided shard id is unknown / shard == null / [indexRouting, index, shardId, version, indicesRouting, version, indicesRouting, version, indicesRouting, this, indexRouting == null]
if provided shard id is unknown / shard == null / [indexRouting, shard, index, shardId, version, indicesRouting, version, indicesRouting, version, indicesRouting, this, shard == null]
if provided shard id is unknown / shard == null / [indexRouting, shardId, version, indicesRouting, version, indicesRouting, version, indicesRouting, this]
if provided shard id is unknown / shard == null / [indexRouting, shard, shardId, version, indicesRouting, version, indicesRouting, version, indicesRouting, this, shard == null]
if sniffIntervalMillis is not greater than 0 / sniffIntervalMillis <= 0 / [sniffIntervalMillis, restClient, sniffIntervalMillis, sniffAfterFailureDelayMillis, hostsSniffer, this, sniffIntervalMillis <= 0]
if maxRetryTimeoutMillis is not greater than 0 / maxRetryTimeoutMillis <= 0 / [maxRetryTimeoutMillis, hosts, maxRetryTimeout, defaultHeaders, failureListener, httpClientConfigCallback, requestConfigCallback, this, maxRetryTimeoutMillis <= 0]
False :


if zip file does not exist, or there was an error reading from the zip file or writing to the destination directory / Files.notExists(zip) / [zip, destDir, prefixToRemove, this, Files.notExists(zip)]
if the listener is set more than once / this.listener != DEFAULT_NOOP_LISTENER / [listener, circuitBreakerService, indicesFieldDataCache, fieldDataCaches, mapperService, listener, this, listener == null]
if the listener is set more than once / this.listener != DEFAULT_NOOP_LISTENER / [listener, circuitBreakerService, indicesFieldDataCache, fieldDataCaches, mapperService, listener, this, this.listener == DEFAULT_NOOP_LISTENER]
if the cidr can not be parsed / fields[0].contains(":") / [fields, cidr, this, fields.length == 2]
if the cidr can not be parsed / fields[0].contains(":") / [fields, cidr, this, fields[0].contains(":")]
if the cidr can not be parsed / fields[0].contains(":") / [fields, addressBytes, accumulator, networkMask, cidr, this]
if the cidr can not be parsed / fields[0].contains(":") / [fields, addressBytes, accumulator, networkMask, blockSize, cidr, this, (accumulator & (blockSize - 1)) == 0]
if the named thing isn't in the registry or the name was deprecated and deprecated names aren't supported. / value == null / [value, name, parseFieldMatcher, xContentLocation, registry, registryName, this, value == null]
if the path is null, empty, invalid or if the field doesn't exist. / context == null / [fieldPath, context, leafKey, path, sourceAndMetadata, ingestMetadata, fieldName, this, context instanceof Map]
if the path is null, empty, invalid or if the field doesn't exist. / context == null / [fieldPath, context, leafKey, path, sourceAndMetadata, ingestMetadata, fieldName, this, context instanceof List]
if the path is null, empty, invalid or if the field doesn't exist. / context == null / [fieldPath, context, leafKey, path, sourceAndMetadata, ingestMetadata, fieldName, this, context == null]



jfreechart-master:{No Variable In Annotation=28, false=2, true=1, No Throw Annotation=36460}
True :
if the number of series keys does not match the number of series in the array. / seriesKeys.size() != data.length / [seriesKeys, data, this, seriesKeys.size() == data.length]
False :
if the key is not recognised. / index < 0 / [index, key, keys, values, indexMap, this, index < 0]
if the key is not recognised. / index < 0 / [index, key, data, this, index < 0]



iosched-master:{No Variable In Annotation=3, false=3, true=3, No Throw Annotation=1282}
True :
if   is negative or zero or the specified charset is not supported. / charset.equals(Util.US_ASCII) / [in, capacity, charset, this]
if   is negative or zero or the specified charset is not supported. / charset.equals(Util.US_ASCII) / [in, capacity, charset, this, capacity < 0]
if   is negative or zero or the specified charset is not supported. / charset.equals(Util.US_ASCII) / [in, capacity, charset, this, !(charset.equals(Util.US_ASCII))]
False :
if   is negative or zero or the specified charset is not supported. / capacity < 0 / [in, capacity, charset, this]
if   is negative or zero or the specified charset is not supported. / capacity < 0 / [in, capacity, charset, this, capacity < 0]
if   is negative or zero or the specified charset is not supported. / capacity < 0 / [in, capacity, charset, this, !(charset.equals(Util.US_ASCII))]



okhttp-master:{No Variable In Annotation=0, false=0, true=0, No Throw Annotation=988}
True :
False :





Android-Universal-Image-Loader-master:{No Variable In Annotation=7, false=3, true=6, No Throw Annotation=248}
True :
if   is negative or zero or the specified charset is not supported. / charset.equals(Util.US_ASCII) / [in, capacity, charset, this]
if   is negative or zero or the specified charset is not supported. / charset.equals(Util.US_ASCII) / [in, capacity, charset, this, capacity < 0]
if   is negative or zero or the specified charset is not supported. / charset.equals(Util.US_ASCII) / [in, capacity, charset, this, !(charset.equals(Util.US_ASCII))]
if <b>configuration</b> parameter is null / configuration == null / [configuration, configuration, engine, defaultListener, instance, this, configuration == null]
if <b>configuration</b> parameter is null / configuration == null / [configuration, configuration, engine, defaultListener, instance, this, this.configuration == null]
if configuration wasn't initialized / configuration == null / [configuration, engine, defaultListener, instance, this, configuration == null]
False :
if   is negative or zero or the specified charset is not supported. / capacity < 0 / [in, capacity, charset, this]
if   is negative or zero or the specified charset is not supported. / capacity < 0 / [in, capacity, charset, this, capacity < 0]
if   is negative or zero or the specified charset is not supported. / capacity < 0 / [in, capacity, charset, this, !(charset.equals(Util.US_ASCII))]



commons-math-master:{No Variable In Annotation=563, false=34, true=71, No Throw Annotation=3688}
True :
if the dimension of the equation data does not match the mapper dimension / equationData.length != dimension / [complete, equationData, firstIndex, dimension, this, equationData.length == dimension]
if the dimension of the equation data does not match the mapper dimension / equationData.length != dimension / [equationData, complete, firstIndex, dimension, this, equationData.length == dimension]
if array is null / array == null / [array, rng, this, array == null]
if array is null / array == null / [array, rng, this, array.length < 2, array.length]
if n > 0. / n > 0 / [k, n, sumImpl, sumSqImpl, minImpl, maxImpl, sumLogImpl, geoMeanImpl, meanImpl, covarianceImpl, this, n > 0]
if the dimension of sc does not match this / sc.dimension != dimension / [sc, covMatrix, dimension, this, sc.dimension == dimension]
if the data array is null / data == null / [data, nobs, nvars, xMatrix, yVector, noIntercept, this, data == null]
if the data array is null / data == null / [data, nobs, nvars, xMatrix, yVector, noIntercept, this, data.length == nobs * (nvars + 1)]
if the data array is null / data == null / [data, nobs, nvars, xMatrix, yVector, noIntercept, this, nobs <= nvars]
if y is null / y == null / [y, xMatrix, yVector, noIntercept, this, y == null]
if y is null / y == null / [y, xMatrix, yVector, noIntercept, this, y.length == 0]
if x is null / x == null / [x, xMatrix, yVector, noIntercept, this, x == null]
if x is null / x == null / [x, xMatrix, yVector, noIntercept, this, x.length == 0]
if x is null / x == null / [x, xMatrix, yVector, noIntercept, this, noIntercept]
if the norm of the quaternion is zero. / norm < Precision.SAFE_MIN / [norm, q0, q1, q2, q3, this, norm < Precision.SAFE_MIN]
if the norm (squared) of the quaternion is zero. / squareNorm < Precision.SAFE_MIN / [squareNorm, q0, q1, q2, q3, this, squareNorm < Precision.SAFE_MIN]
if the provided time is &lt; 0 / maxTime < 0 / [maxTime, unit, this, maxTime < 0]
if the population limit is not a positive number (&lt; 1) / populationLimit <= 0 / [chromosomes, populationLimit, this, chromosomes == null]
if the population limit is not a positive number (&lt; 1) / populationLimit <= 0 / [chromosomes, populationLimit, this, populationLimit <= 0]
if the population limit is not a positive number (&lt; 1) / populationLimit <= 0 / [chromosomes, populationLimit, this, chromosomes.size() > populationLimit]
if the population limit is not a positive number (&lt; 1) / populationLimit <= 0 / [populationLimit, chromosomes, populationLimit, this, populationLimit <= 0]
if the population limit is not a positive number (&lt; 1) / populationLimit <= 0 / [populationLimit, chromosomes, populationLimit, this, populationLimit < chromosomes.size()]
if the number of generations is &lt; 1 / maxGenerations <= 0 / [maxGenerations, this, maxGenerations <= 0]
if the space dimension is &lt; 1 / dimension < 1 / [dimension, is, this, dimension < 1]
if the space dimension is &lt; 1 / dimension < 1 / [lastDimension, dimension, is, this, lastDimension < dimension]
if generator is null / generator == null / [generator, alpha, beta, this, generator == null]
if generator is null / generator == null / [generator, alpha, beta, this]
if generator is null / generator == null / [generator, alpha, beta, this]
if generator is null / generator == null / [generator, alpha, beta, this]
if the transition matrix is non square / transitionMatrix.isSquare() / [process, measurement, this, processModel.getControlMatrix() == null]
if the transition matrix is non square / transitionMatrix.isSquare() / [processNoise, measNoise, process, measurement, this, processModel.getInitialStateEstimate() == null]
if the transition matrix is non square / transitionMatrix.isSquare() / [processNoise, measNoise, process, measurement, this, transitionMatrix.getColumnDimension() == stateEstimation.getDimension()]
if the transition matrix is non square / transitionMatrix.isSquare() / [processNoise, measNoise, process, measurement, this, processModel.getInitialErrorCovariance() == null]
if the transition matrix is non square / transitionMatrix.isSquare() / [processNoise, measNoise, process, measurement, this, !transitionMatrix.isSquare()]
if the transition matrix is non square / transitionMatrix.isSquare() / [processNoise, measNoise, process, measurement, this]
if the transition matrix is non square / transitionMatrix.isSquare() / [processNoise, measNoise, process, measurement, this, measurementMatrix.getColumnDimension() == transitionMatrix.getRowDimension()]
if the transition matrix is non square / transitionMatrix.isSquare() / [processNoise, measNoise, process, measurement, this, measNoise.getRowDimension() == measurementMatrix.getRowDimension()]
if matrix is not square / matrix.isSquare() / [matrix, singularityThreshold, this, !matrix.isSquare()]
if matrix is not square / matrix.isSquare() / [matrix, threshold, this, !matrix.isSquare()]
if matrix is not square / matrix.isSquare() / [matrix, threshold, this, matrix instanceof DiagonalMatrix]
if row or column dimension is not positive / rowDimension < 1 / [rowDimension, columnDimension, this, rowDimension < 1]
if row or column dimension is not positive / columnDimension < 1 / [rowDimension, columnDimension, this, rowDimension < 1]
if row or column dimension is not positive / rowDimension < 1 / [rowDimension, columnDimension, this, columnDimension < 1]
if row or column dimension is not positive / columnDimension < 1 / [rowDimension, columnDimension, this, columnDimension < 1]
if the matrix is not square / matrix.isSquare() / [matrix, this, !matrix.isSquare()]
if the matrix is not square / matrix.isSquare() / [matrix, this, !matrix.isSquare()]
if the norm is zero. / norm == 0 / [norm, this, norm == 0]
if the norm is zero. / norm == 0 / [norm, this, norm == 0]
if the matrix is not square. / matrix.isSquare() / [matrix, this, !matrix.isSquare()]
if row or column dimension is not positive. / rowDimension <= 0 / [field, rowDimension, columnDimension, this, rowDimension <= 0]
if row or column dimension is not positive. / columnDimension <= 0 / [field, rowDimension, columnDimension, this, rowDimension <= 0]
if row or column dimension is not positive. / rowDimension <= 0 / [field, rowDimension, columnDimension, this, columnDimension <= 0]
if row or column dimension is not positive. / columnDimension <= 0 / [field, rowDimension, columnDimension, this, columnDimension <= 0]
if matrix is not square / matrix.isSquare() / [matrix, this, !matrix.isSquare()]
if the matrix is not square. / matrix.isSquare() / [matrix, relativeSymmetryThreshold, absolutePositivityThreshold, this, !matrix.isSquare()]
if Object <code>o</code> is  . / o == null / [o, this, o == null]
if Object <code>o</code> is  . / o == null / [o, this, o instanceof Number]
if n &lt; 0. / n < 0 / [n, this, n < 0]
if n &lt; 0. / n < 0 / [n, this, n == 2]
if n &lt; 0. / n < 0 / [n, this, n == 1]
if n &lt; 0. / n < 0 / [n, this, isPrime(n)]
if n &lt; 0. / n < 0 / [rem, n, this, 0 == rem]
if n &lt; 0. / n < 0 / [rem, n, this, 1 == rem]
if the space dimension of the given samples does not match the space dimension of the microsphere. / dimension != xval[0].length / [xval, yval, exponent, microsphere, sharedSphere, noInterpolationTolerance, this]
if the space dimension of the given samples does not match the space dimension of the microsphere. / dimension != xval[0].length / [xval, yval, exponent, microsphere, sharedSphere, noInterpolationTolerance, this, xval.length == 0]
if the space dimension of the given samples does not match the space dimension of the microsphere. / dimension != xval[0].length / [xval, yval, exponent, microsphere, sharedSphere, noInterpolationTolerance, this, xval.length == yval.length]
if the space dimension of the given samples does not match the space dimension of the microsphere. / dimension != xval[0].length / [xval, yval, exponent, microsphere, sharedSphere, noInterpolationTolerance, this, xval[0] == null]
if the space dimension of the given samples does not match the space dimension of the microsphere. / dimension != xval[0].length / [dimension, xval, yval, exponent, microsphere, sharedSphere, noInterpolationTolerance, this, dimension == xval[0].length]
if no initial simplex was passed to the  method. / simplex == null / [simplex, this, simplex == null]
if no initial simplex was passed to the  method. / simplex == null / [simplex, this]
if the observations vector and the scale matrix dimensions do not match (objective function dimension is checked only when the   method is called) / observations.length != scale.getColumnDimension() / [function, observations, scale, this, observations.length == scale.getColumnDimension()]
False :
if clusters are all empty / selected == null / [maxVariance, selected, clusters, k, maxIterations, random, emptyStrategy, this, selected == null]
if clusters are all empty / selectedCluster == null / [maxDistance, selectedCluster, selectedPoint, clusters, k, maxIterations, random, emptyStrategy, this, selectedCluster == null]
if the resulting numerator or denominator cannot be represented in an  . / w.bitLength() > 31 / [fraction, isAdd, denominator, numerator, this, fraction == null]
if the resulting numerator or denominator cannot be represented in an  . / w.bitLength() > 31 / [fraction, isAdd, denominator, numerator, this, numerator == 0]
if the resulting numerator or denominator cannot be represented in an  . / w.bitLength() > 31 / [fraction, isAdd, denominator, numerator, this, fraction.numerator == 0]
if the resulting numerator or denominator cannot be represented in an  . / w.bitLength() > 31 / [d1, fraction, isAdd, denominator, numerator, this, d1==1]
if the resulting numerator or denominator cannot be represented in an  . / w.bitLength() > 31 / [d1, uvp, upv, t, tmodd1, d2, w, fraction, isAdd, denominator, numerator, this, w.bitLength() > 31, w.bitLength()]
if the fraction to divide by is zero / fraction.numerator.signum() == 0 / [fraction, numerator, denominator, this, fraction.numerator.signum() == 0]
if the fraction to divide by is zero / fraction.numerator.signum() == 0 / [fraction, numerator, denominator, this, numerator.signum() == 0]
if the length of the data array is not equal to <code>nobs * (nvars + 1)</code> / data.length != nobs * (nvars + 1) / [data, nobs, nvars, xMatrix, yVector, noIntercept, this, data == null]
if the length of the data array is not equal to <code>nobs * (nvars + 1)</code> / data.length != nobs * (nvars + 1) / [data, nobs, nvars, xMatrix, yVector, noIntercept, this, data.length == nobs * (nvars + 1)]
if the length of the data array is not equal to <code>nobs * (nvars + 1)</code> / data.length != nobs * (nvars + 1) / [data, nobs, nvars, xMatrix, yVector, noIntercept, this, nobs <= nvars]
if the tournament arity is bigger than the population size / population.getPopulationSize() < this.arity / [population, arity, this, population.getPopulationSize() < this.arity]
if the mean and covariance arrays dimensions do not match. / mean.length != order / [order, mean, covariance, small, generator, this, mean.length == order]
if the target sum is infinite or  . / Double.isInfinite(normalizedSum) / [sum, len, out, values, normalizedSum, this, sum == 0]
if the target sum is infinite or  . / Double.isNaN(normalizedSum) / [sum, len, out, values, normalizedSum, this, sum == 0]
if the array indices are not valid, the weights array contains NaN, infinite or negative elements, or there are no positive weights. / containsPositiveWeight / [values, weights, begin, length, allowEmpty, this]
if the array indices are not valid, the weights array contains NaN, infinite or negative elements, or there are no positive weights. / containsPositiveWeight / [containsPositiveWeight, values, weights, begin, length, allowEmpty, this, !containsPositiveWeight]
if the size of  does not match the size of the array given in the constructor. / c.length != dimension / [c, dimension, uniCounterOffset, size, totalSize, last, this, c.length == dimension]
if the length of x and y don't match the row, column height of f / xLen != f.length / [x, y, f, this]
if the length of x and y don't match the row, column height of f / yLen != f[0].length / [x, y, f, this]
if the length of x and y don't match the row, column height of f / xLen != f.length / [xLen, yLen, x, y, f, this]
if the length of x and y don't match the row, column height of f / yLen != f[0].length / [xLen, yLen, x, y, f, this]
if the length of x and y don't match the row, column height of f / xLen != f.length / [xLen, yLen, x, y, f, this]
if the length of x and y don't match the row, column height of f / yLen != f[0].length / [xLen, yLen, x, y, f, this]
if the length of x and y don't match the row, column height of f / xLen != f.length / [xLen, yLen, x, y, f, this, xLen == f.length]
if the length of x and y don't match the row, column height of f / yLen != f[0].length / [xLen, yLen, x, y, f, this, xLen == f.length]
if the length of x and y don't match the row, column height of f / xLen != f.length / [xLen, yLen, x, y, f, this, yLen == f[0].length]
if the length of x and y don't match the row, column height of f / yLen != f[0].length / [xLen, yLen, x, y, f, this, yLen == f[0].length]
if the bandwidth is too small to accomodate the size of the input data (i.e. the bandwidth must be larger than 2/n). / bandwidthInPoints < 2 / [xval, yval, weights, bandwidth, robustnessIters, accuracy, this, xval.length == yval.length]
if the bandwidth is too small to accomodate the size of the input data (i.e. the bandwidth must be larger than 2/n). / bandwidthInPoints < 2 / [n, xval, yval, weights, bandwidth, robustnessIters, accuracy, this, n == 0]
if the bandwidth is too small to accomodate the size of the input data (i.e. the bandwidth must be larger than 2/n). / bandwidthInPoints < 2 / [n, xval, yval, weights, bandwidth, robustnessIters, accuracy, this, n == 1]
if the bandwidth is too small to accomodate the size of the input data (i.e. the bandwidth must be larger than 2/n). / bandwidthInPoints < 2 / [n, xval, yval, weights, bandwidth, robustnessIters, accuracy, this, n == 2]
if the bandwidth is too small to accomodate the size of the input data (i.e. the bandwidth must be larger than 2/n). / bandwidthInPoints < 2 / [n, bandwidthInPoints, xval, yval, weights, bandwidth, robustnessIters, accuracy, this, bandwidthInPoints < 2]



retrofit-master:{No Variable In Annotation=0, false=0, true=0, No Throw Annotation=150}
True :
False :





